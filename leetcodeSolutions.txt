// Given an array of integers nums and an integer target, 
// return indices of the two numbers such that they add up to target.
// You may assume that each input would have exactly one solution, 
// and you may not use the same element twice.
// You can return the answer in any order.

//Solution

import java.util.Arrays;
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
     HashMap<String, Integer> number = new HashMap<String, Integer>();
        
        for (int i = 0; i < nums.length; i++) {
            number.put(Integer.toString(nums[i]), i);
        }
        
        for (int i = 0, place = i; i < nums.length; i++) {
            int distance = target - nums[i];
            
            if (number.containsKey(Integer.toString(distance))) {
                place = number.get(Integer.toString(distance));
                if (i != place) {
                    return new int[]{i, place};
                }
            }
        }
        return new int[]{0,0};
    }
}

// Given an input string s, reverse the order of the words.

// A word is defined as a sequence of non-space characters. 
// The words in s will be separated by at least one space.

// Return a string of the words in reverse order concatenated by a single space.

class Solution {
    public String reverseWords(String s) {
        String[] temp = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = temp.length - 1; i >= 0; i --) {
            if(!temp[i].equals("")) {
                sb.append(temp[i]).append(" ");
            }
        }
        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);
                                        
    }
}

// You have n  tiles, where each tile has one letter tiles[i] printed on it.
// Return the number of possible non-empty sequences of letters 
// you can make using the letters printed on those tiles.


class Solution {
    public int numTilePossibilities(String tiles) {
        if (tiles == null || tiles.length() == 0) {
            return 0;
        }
        
        HashSet<String> hs = new HashSet<>();
        char [] hold = tiles.toCharArray();
        boolean [] used = new boolean[tiles.length()];
        dfs(hold, used, "", hs);
        return hs.size();
    }
    
    private void dfs(char [] hold, boolean[] used, String item, HashSet<String> hs) {
        for (int i = 0; i < used.length; i++) {
            if(!used[i]){
                used[i] = true;
                hs.add(item + hold[i]);
                dfs(hold, used, item + hold[i], hs);
                used[i] = false;
            }
        }
    }
}

// Given a string s. You should re-order the string using the following algorithm:

// Pick the smallest character from s and append it to the result.
// Pick the smallest character from s which is greater than the last appended 
// character to the result and append it.

// Repeat step 2 until you cannot pick more characters.

// Pick the largest character from s and append it to the result.
// Pick the largest character from s which is smaller than the last 
// appended character to the result and append it.

// Repeat step 5 until you cannot pick more characters.

// Repeat the steps from 1 to 6 until you pick all characters from s.
// In each step, If the smallest or the largest character appears more than once 
// you can choose any occurrence and append it to the result.

// Return the result string after sorting s with this algorithm.

class Solution {
    public String sortString(String s) {
        int[] alphabet = new int[26];
        for (char c : s.toCharArray()) {
            alphabet[c - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        while(sb.length() != s.length()) {
            for (int i = 0; i < 26; i++) {
                if (alphabet[i] !=0) {
                    sb.append((char) (97 + i));
                    alphabet[i]--;
                }
            }
            for(int j = 25; j >= 0; j--) {
                if(alphabet[j] != 0) {
                    sb.append((char) (97 + j));
                    alphabet[j]--;
                }
            }
            
        }
        return sb.toString();
    }
}

// You are given an m x n integer grid accounts where accounts[i][j] 
// is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. 
// Return the wealth that the richest customer has.

// A customer's wealth is the amount of money they have in all their bank accounts. 
// The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        int m = accounts.length;
        if (m==0) {
            return 0;
        }
        int n = accounts[0].length;
        int ans = 0;
        for (int i = 0; i < m; i++) {
            int res = 0;
            for(int j = 0; j < n; j++){
                res += accounts[i][j];
            }
            ans = Math.max(ans, res);
        }
        return ans;
    }
}

// Given an array nums of integers, 
// return how many of them contain an even number of digits.

class Solution {
    
    public boolean isEven (int num) {
         int count = 0;
       while(num != 0) {
           count++;
           num = num /10;
       }
        return count % 2 ==0;
    }
    
    public int findNumbers(int[] nums) {
       int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isEven(nums[i])) {
                res++;
            }
        }
        return res;
    }
}

// International Morse Code defines a standard encoding where each letter is 
// mapped to a series of dots and dashes, 
// as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

// Now, given a list of words, 
// each word can be written as a concatenation of the Morse code of each letter. 
// For example, "cab" can be written as "-.-..--...", 
// (which is the concatenation "-.-." + ".-" + "-..."). 
// We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.
class Solution {
    
    private final String[] VALUE = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    public int uniqueMorseRepresentations(String[] words) {
        Set<String> hold = new HashSet();
        for (String temp : words) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < temp.length(); i++) {
                char c = temp.charAt(i);
                sb.append(VALUE[c - 'a']);
            }
            hold.add(sb.toString());
        }
        return hold.size();
    }
}

// Given an 2D board, count how many battleships are in it. 
// The battleships are represented with 'X's, empty slots are represented with '.'s. 
// You may assume the following rules:

// You receive a valid board, made of only battleships or empty slots.

// Battleships can only be placed horizontally or vertically. 
// In other words, they can only be made of the shape 1xN (1 row, N columns) 
// or Nx1 (N rows, 1 column), where N can be of any size.

// At least one horizontal or vertical cell separates between two battleships - 
// there are no adjacent battleships.

class Solution {
    public int countBattleships(char[][] board) {
       
        int count = 0;
        
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == '.') {
                    continue;
                }
                if (i + 1 < board.length && board[i + 1][j] == 'X' || 
                   j + 1 < board[0].length && board[i][j + 1] == 'X') {
                    continue;
                }
                count++;
            }
            
        }
        return count;
    }
}

// Ugly Number haha

// Write a program to check whether a given number is an ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

class Solution {
    
    private static final int[] UGLY = {2, 3, 5};

    public boolean isUgly(int num) {
        if (num == 0) return false;
        if (num == 1) return true;
        
        for (int i = 0; i < UGLY.length; i++) {
            if (num % UGLY[i] == 0) {
                num = num / UGLY[i];
                return isUgly(num);
            }
        }
        return false;
    }
}

// Given two sorted integer arrays nums1 and nums2, 
// merge nums2 into nums1 as one sorted array.

// The number of elements initialized in nums1 and nums2 are m and n respectively. 
// You may assume that nums1 has a size equal to m + n such that it has enough 
// space to hold additional elements from nums2.

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n == 0) return;
        
        int[] hold = new int[m];
        for (int i = 0; i < m; i++) {
            hold[i] = nums1[i];
        }
        
        int i = 0, j = 0, k = 0;
        while((i < m) || (j < n)) {
            if (i == m){
                nums1[k++] = nums2[j++];
            }
            else if (j == n) {
                nums1[k++] = hold[i++];
            }
            else if (hold[i] <= nums2[j]) {
                nums1[k++] = hold[i++];
            }
            else{
                nums1[k++] = nums2[j++];
            }
        }
    }
}

// There is a biker going on a road trip. 
// The road trip consists of n + 1 points at different altitudes. 
// The biker starts his trip on point 0 with altitude equal 0.

// You are given an integer array gain of length n where gain[i] is the 
// net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). 
// Return the highest altitude of a point.

class Solution {
    public int largestAltitude(int[] gain) {
        int ans = 0;
        int h = 0;
        for (int i = 0; i < gain.length; i++) {
            h += gain[i];
            ans = Math.max(ans, h);
        }
        return ans;
    }
}

// Given a valid (IPv4) IP address, 
// return a defanged version of that IP address.

// A defanged IP address replaces every period "." with "[.]".

 class Solution {
    public String defangIPaddr(String address) {
        String defang = "";
        for(int i = 0; i < address.length(); i++) {
            char c = address.charAt(i);
            if(c == '.') {
                defang += "[.]";
            }
            else {
                defang += c;
            }
        }
        return defang;
    }
}

// Given a string s. You should re-order the string using the following algorithm:

// Pick the smallest character from s and append it to the result.
// Pick the smallest character from s which is greater than the 
// last appended character to the result and append it.
// Repeat step 2 until you cannot pick more characters.

// Pick the largest character from s and append it to the result.
// Pick the largest character from s which is smaller than the last 
// appended character to the result and append it.

// Repeat step 5 until you cannot pick more characters.

// Repeat the steps from 1 to 6 until you pick all characters from s.
// In each step, If the smallest or the largest character appears more than once 
// you can choose any occurrence and append it to the result.

// Return the result string after sorting s with this algorithm.

class Solution {
    public String sortString(String s) {
        int[] alphabet = new int[26];
        for (char c : s.toCharArray()) {
            alphabet[c - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        while(sb.length() != s.length()) {
            for (int i = 0; i < 26; i++) {
                if (alphabet[i] !=0) {
                    sb.append((char) (97 + i));
                    alphabet[i]--;
                }
            }
            for(int j = 25; j >= 0; j--) {
                if(alphabet[j] != 0) {
                    sb.append((char) (97 + j));
                    alphabet[j]--;
                }
            }
            
        }
        return sb.toString();
    }
}

// Reverse bits of a given 32 bits unsigned integer.

// Note:

// Note that in some languages such as Java, there is no unsigned integer type. 
// In this case, both input and output will be // given as a signed integer type. 
// They should not affect your implementation, as the integer's internal binary 
// representation is the same, whether it is signed or unsigned.

// In Java, the compiler represents the signed integers using 2's complement notation. 
// Therefore, in Example 2 above, the 
// input represents the signed integer -3 and the output represents the signed integer 
// -1073741825.

// Follow up:

// If this function is called many times, how would you optimize it?

public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        for (int i = 0; i < 16; i++) {
            n = findBits(n, i, 32 - i - 1);
        }
        return n;
    }
    
    public int findBits(int n, int i, int j) {
        int a = (n >> j) & 1;
        int b = (n >> i) & 1;
        
        if ((a ^ b) != 0) {
            return n ^= (1 << i) | (1 << j);
        }
        
        return n;
    }
}

// Given a string s formed by digits ('0' - '9') and '#' . 
// We want to map s to English lowercase characters as follows:

// Characters ('a' to 'i') are represented by ('1' to '9') respectively.
// Characters ('j' to 'z') are represented by ('10#' to '26#') respectively. 
// Return the string formed after mapping.

// It's guaranteed that a unique mapping will always exist.

class Solution {
    public String freqAlphabets(String s) {
 StringBuilder sb = new StringBuilder();
    int idx = 0;
    int n = s.length();
    while (idx < n) {
      char c = s.charAt(idx);
      int asciiAdd = -1;
      if (idx + 2 < n && s.charAt(idx + 2) == '#') {
        asciiAdd = Integer.parseInt(s.substring(idx, idx + 2));
        idx += 3;
      }
      else {
        asciiAdd = Integer.parseInt(s.substring(idx, idx + 1));
        idx++;
      }
      sb.append((char) (96 + asciiAdd));
    }
    return sb.toString();
    }
}

// Given a signed 32-bit integer x, return x with its digits reversed. 
// If reversing x causes the value to go outside the signed 32-bit integer range 
// [-231, 231 - 1], then return 0.

// Assume the environment does not allow you to store 64-bit integers 
// (signed or unsigned).

class Solution {
    public int reverse(int x) {
        int ans = 0;
        while(x != 0) {
            int r = x % 10;
            if (ans > Integer.MAX_VALUE / 10 || ans < Integer.MIN_VALUE / 10) {
                return 0;
            }
            ans = ans * 10 + r;
            x /= 10;
        }
        return ans;
    }
}

// Given a string s and an integer k.

// Return the maximum number of vowel letters in any substring of s with length k.

// Vowel letters in English are (a, e, i, o, u).

class Solution {
    public boolean isVowelValid(char v) {
        return ( v == 'a' || v == 'e' || v == 'i' || v == 'o' || v =='u');
    }
    
    public int maxVowels(String s, int k) {
        if (s.length() < k) {
            return 0;
        }
        int max = 0, n = s.length(), count = 0;
        for (int i = 0; i < k; i++) {
            if (isVowelValid(s.charAt(i))) {
                count++;
            }
        }
        max = count;
        
        for (int i = k; i < n; i++) {
            if (isVowelValid(s.charAt(i - k))) {
                count--;
            }
            if (isVowelValid(s.charAt(i))) {
                count++;
            }
            max = Math.max(max, count);
        }
        return max;
    }
}
