// Given an array of integers nums and an integer target, 
// return indices of the two numbers such that they add up to target.
// You may assume that each input would have exactly one solution, 
// and you may not use the same element twice.
// You can return the answer in any order.

//Solution

import java.util.Arrays;
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
     HashMap<String, Integer> number = new HashMap<String, Integer>();
        
        for (int i = 0; i < nums.length; i++) {
            number.put(Integer.toString(nums[i]), i);
        }
        
        for (int i = 0, place = i; i < nums.length; i++) {
            int distance = target - nums[i];
            
            if (number.containsKey(Integer.toString(distance))) {
                place = number.get(Integer.toString(distance));
                if (i != place) {
                    return new int[]{i, place};
                }
            }
        }
        return new int[]{0,0};
    }
}

// Given an input string s, reverse the order of the words.

// A word is defined as a sequence of non-space characters. 
// The words in s will be separated by at least one space.

// Return a string of the words in reverse order concatenated by a single space.

class Solution {
    public String reverseWords(String s) {
        String[] temp = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = temp.length - 1; i >= 0; i --) {
            if(!temp[i].equals("")) {
                sb.append(temp[i]).append(" ");
            }
        }
        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);
                                        
    }
}

// You have n  tiles, where each tile has one letter tiles[i] printed on it.
// Return the number of possible non-empty sequences of letters 
// you can make using the letters printed on those tiles.


class Solution {
    public int numTilePossibilities(String tiles) {
        if (tiles == null || tiles.length() == 0) {
            return 0;
        }
        
        HashSet<String> hs = new HashSet<>();
        char [] hold = tiles.toCharArray();
        boolean [] used = new boolean[tiles.length()];
        dfs(hold, used, "", hs);
        return hs.size();
    }
    
    private void dfs(char [] hold, boolean[] used, String item, HashSet<String> hs) {
        for (int i = 0; i < used.length; i++) {
            if(!used[i]){
                used[i] = true;
                hs.add(item + hold[i]);
                dfs(hold, used, item + hold[i], hs);
                used[i] = false;
            }
        }
    }
}

// Given a string s. You should re-order the string using the following algorithm:

// Pick the smallest character from s and append it to the result.
// Pick the smallest character from s which is greater than the last appended 
// character to the result and append it.

// Repeat step 2 until you cannot pick more characters.

// Pick the largest character from s and append it to the result.
// Pick the largest character from s which is smaller than the last 
// appended character to the result and append it.

// Repeat step 5 until you cannot pick more characters.

// Repeat the steps from 1 to 6 until you pick all characters from s.
// In each step, If the smallest or the largest character appears more than once 
// you can choose any occurrence and append it to the result.

// Return the result string after sorting s with this algorithm.

class Solution {
    public String sortString(String s) {
        int[] alphabet = new int[26];
        for (char c : s.toCharArray()) {
            alphabet[c - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        while(sb.length() != s.length()) {
            for (int i = 0; i < 26; i++) {
                if (alphabet[i] !=0) {
                    sb.append((char) (97 + i));
                    alphabet[i]--;
                }
            }
            for(int j = 25; j >= 0; j--) {
                if(alphabet[j] != 0) {
                    sb.append((char) (97 + j));
                    alphabet[j]--;
                }
            }
            
        }
        return sb.toString();
    }
}

// You are given an m x n integer grid accounts where accounts[i][j] 
// is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. 
// Return the wealth that the richest customer has.

// A customer's wealth is the amount of money they have in all their bank accounts. 
// The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        int m = accounts.length;
        if (m==0) {
            return 0;
        }
        int n = accounts[0].length;
        int ans = 0;
        for (int i = 0; i < m; i++) {
            int res = 0;
            for(int j = 0; j < n; j++){
                res += accounts[i][j];
            }
            ans = Math.max(ans, res);
        }
        return ans;
    }
}

// Given an array nums of integers, 
// return how many of them contain an even number of digits.

class Solution {
    
    public boolean isEven (int num) {
         int count = 0;
       while(num != 0) {
           count++;
           num = num /10;
       }
        return count % 2 ==0;
    }
    
    public int findNumbers(int[] nums) {
       int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isEven(nums[i])) {
                res++;
            }
        }
        return res;
    }
}

// International Morse Code defines a standard encoding where each letter is 
// mapped to a series of dots and dashes, 
// as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

// Now, given a list of words, 
// each word can be written as a concatenation of the Morse code of each letter. 
// For example, "cab" can be written as "-.-..--...", 
// (which is the concatenation "-.-." + ".-" + "-..."). 
// We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.
class Solution {
    
    private final String[] VALUE = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    public int uniqueMorseRepresentations(String[] words) {
        Set<String> hold = new HashSet();
        for (String temp : words) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < temp.length(); i++) {
                char c = temp.charAt(i);
                sb.append(VALUE[c - 'a']);
            }
            hold.add(sb.toString());
        }
        return hold.size();
    }
}