// Given an array of integers nums and an integer target, 
// return indices of the two numbers such that they add up to target.
// You may assume that each input would have exactly one solution, 
// and you may not use the same element twice.
// You can return the answer in any order.

//Solution

import java.util.Arrays;
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
     HashMap<String, Integer> number = new HashMap<String, Integer>();
        
        for (int i = 0; i < nums.length; i++) {
            number.put(Integer.toString(nums[i]), i);
        }
        
        for (int i = 0, place = i; i < nums.length; i++) {
            int distance = target - nums[i];
            
            if (number.containsKey(Integer.toString(distance))) {
                place = number.get(Integer.toString(distance));
                if (i != place) {
                    return new int[]{i, place};
                }
            }
        }
        return new int[]{0,0};
    }
}

// Given an input string s, reverse the order of the words.

// A word is defined as a sequence of non-space characters. 
// The words in s will be separated by at least one space.

// Return a string of the words in reverse order concatenated by a single space.

class Solution {
    public String reverseWords(String s) {
        String[] temp = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = temp.length - 1; i >= 0; i --) {
            if(!temp[i].equals("")) {
                sb.append(temp[i]).append(" ");
            }
        }
        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);
                                        
    }
}

// You have n  tiles, where each tile has one letter tiles[i] printed on it.
// Return the number of possible non-empty sequences of letters 
// you can make using the letters printed on those tiles.


class Solution {
    public int numTilePossibilities(String tiles) {
        if (tiles == null || tiles.length() == 0) {
            return 0;
        }
        
        HashSet<String> hs = new HashSet<>();
        char [] hold = tiles.toCharArray();
        boolean [] used = new boolean[tiles.length()];
        dfs(hold, used, "", hs);
        return hs.size();
    }
    
    private void dfs(char [] hold, boolean[] used, String item, HashSet<String> hs) {
        for (int i = 0; i < used.length; i++) {
            if(!used[i]){
                used[i] = true;
                hs.add(item + hold[i]);
                dfs(hold, used, item + hold[i], hs);
                used[i] = false;
            }
        }
    }
}

// Given a string s. You should re-order the string using the following algorithm:

// Pick the smallest character from s and append it to the result.
// Pick the smallest character from s which is greater than the last appended 
// character to the result and append it.

// Repeat step 2 until you cannot pick more characters.

// Pick the largest character from s and append it to the result.
// Pick the largest character from s which is smaller than the last 
// appended character to the result and append it.

// Repeat step 5 until you cannot pick more characters.

// Repeat the steps from 1 to 6 until you pick all characters from s.
// In each step, If the smallest or the largest character appears more than once 
// you can choose any occurrence and append it to the result.

// Return the result string after sorting s with this algorithm.

class Solution {
    public String sortString(String s) {
        int[] alphabet = new int[26];
        for (char c : s.toCharArray()) {
            alphabet[c - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        while(sb.length() != s.length()) {
            for (int i = 0; i < 26; i++) {
                if (alphabet[i] !=0) {
                    sb.append((char) (97 + i));
                    alphabet[i]--;
                }
            }
            for(int j = 25; j >= 0; j--) {
                if(alphabet[j] != 0) {
                    sb.append((char) (97 + j));
                    alphabet[j]--;
                }
            }
            
        }
        return sb.toString();
    }
}

// You are given an m x n integer grid accounts where accounts[i][j] 
// is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. 
// Return the wealth that the richest customer has.

// A customer's wealth is the amount of money they have in all their bank accounts. 
// The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        int m = accounts.length;
        if (m==0) {
            return 0;
        }
        int n = accounts[0].length;
        int ans = 0;
        for (int i = 0; i < m; i++) {
            int res = 0;
            for(int j = 0; j < n; j++){
                res += accounts[i][j];
            }
            ans = Math.max(ans, res);
        }
        return ans;
    }
}

// Given an array nums of integers, 
// return how many of them contain an even number of digits.

class Solution {
    
    public boolean isEven (int num) {
         int count = 0;
       while(num != 0) {
           count++;
           num = num /10;
       }
        return count % 2 ==0;
    }
    
    public int findNumbers(int[] nums) {
       int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (isEven(nums[i])) {
                res++;
            }
        }
        return res;
    }
}

// International Morse Code defines a standard encoding where each letter is 
// mapped to a series of dots and dashes, 
// as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

// Now, given a list of words, 
// each word can be written as a concatenation of the Morse code of each letter. 
// For example, "cab" can be written as "-.-..--...", 
// (which is the concatenation "-.-." + ".-" + "-..."). 
// We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.
class Solution {
    
    private final String[] VALUE = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    public int uniqueMorseRepresentations(String[] words) {
        Set<String> hold = new HashSet();
        for (String temp : words) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < temp.length(); i++) {
                char c = temp.charAt(i);
                sb.append(VALUE[c - 'a']);
            }
            hold.add(sb.toString());
        }
        return hold.size();
    }
}

// Given an 2D board, count how many battleships are in it. 
// The battleships are represented with 'X's, empty slots are represented with '.'s. 
// You may assume the following rules:

// You receive a valid board, made of only battleships or empty slots.

// Battleships can only be placed horizontally or vertically. 
// In other words, they can only be made of the shape 1xN (1 row, N columns) 
// or Nx1 (N rows, 1 column), where N can be of any size.

// At least one horizontal or vertical cell separates between two battleships - 
// there are no adjacent battleships.

class Solution {
    public int countBattleships(char[][] board) {
       
        int count = 0;
        
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == '.') {
                    continue;
                }
                if (i + 1 < board.length && board[i + 1][j] == 'X' || 
                   j + 1 < board[0].length && board[i][j + 1] == 'X') {
                    continue;
                }
                count++;
            }
            
        }
        return count;
    }
}

// Ugly Number haha

// Write a program to check whether a given number is an ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

class Solution {
    
    private static final int[] UGLY = {2, 3, 5};

    public boolean isUgly(int num) {
        if (num == 0) return false;
        if (num == 1) return true;
        
        for (int i = 0; i < UGLY.length; i++) {
            if (num % UGLY[i] == 0) {
                num = num / UGLY[i];
                return isUgly(num);
            }
        }
        return false;
    }
}

// Given two sorted integer arrays nums1 and nums2, 
// merge nums2 into nums1 as one sorted array.

// The number of elements initialized in nums1 and nums2 are m and n respectively. 
// You may assume that nums1 has a size equal to m + n such that it has enough 
// space to hold additional elements from nums2.

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n == 0) return;
        
        int[] hold = new int[m];
        for (int i = 0; i < m; i++) {
            hold[i] = nums1[i];
        }
        
        int i = 0, j = 0, k = 0;
        while((i < m) || (j < n)) {
            if (i == m){
                nums1[k++] = nums2[j++];
            }
            else if (j == n) {
                nums1[k++] = hold[i++];
            }
            else if (hold[i] <= nums2[j]) {
                nums1[k++] = hold[i++];
            }
            else{
                nums1[k++] = nums2[j++];
            }
        }
    }
}